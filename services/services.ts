//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import { AuthorizedApiBase, IConfig } from ".";

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client extends AuthorizedApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8090";
    }

    /**
     * genToken
     * @param email (optional) email
     * @return OK
     */
    genTokenUsingGET(email: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/account/refreshtoken?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGenTokenUsingGET(_response));
        });
    }

    protected processGenTokenUsingGET(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * resetPassword
     * @param email (optional) email
     * @param password (optional) password
     * @param token (optional) token
     * @return OK
     */
    resetPasswordUsingPOST(email: string | null | undefined, password: string | null | undefined, token: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/account/resetpassword?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processResetPasswordUsingPOST(_response));
        });
    }

    protected processResetPasswordUsingPOST(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * updateStatus
     * @param id (optional) id
     * @param status (optional) status
     * @return OK
     */
    updateStatusUsingPOST(id: number | null | undefined, status: number | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/account/update-status?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateStatusUsingPOST(_response));
        });
    }

    protected processUpdateStatusUsingPOST(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * verifyToken
     * @param email (optional) email
     * @param token (optional) token
     * @return OK
     */
    verifyTokenUsingGET(email: string | null | undefined, token: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/account/verifytoken?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processVerifyTokenUsingGET(_response));
        });
    }

    protected processVerifyTokenUsingGET(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * getListAttend
     * @param classId (optional) classId
     * @param studentId (optional) studentId
     * @param subjectId (optional) subjectId
     * @return OK
     */
    getListAttendUsingGET(classId: number | null | undefined, studentId: number | null | undefined, subjectId: string | null | undefined): Promise<AttendDTO[]> {
        let url_ = this.baseUrl + "/api/attendance/list?";
        if (classId !== undefined && classId !== null)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        if (studentId !== undefined && studentId !== null)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (subjectId !== undefined && subjectId !== null)
            url_ += "subjectId=" + encodeURIComponent("" + subjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetListAttendUsingGET(_response));
        });
    }

    protected processGetListAttendUsingGET(response: Response): Promise<AttendDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(AttendDTO.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttendDTO[]>(null as any);
    }

    /**
     * listClass
     * @param subjectId subjectId
     * @return OK
     */
    listClassUsingGET(subjectId: string): Promise<any[]> {
        let url_ = this.baseUrl + "/api/class-student?";
        if (subjectId === undefined || subjectId === null)
            throw new Error("The parameter 'subjectId' must be defined and cannot be null.");
        else
            url_ += "subjectId=" + encodeURIComponent("" + subjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processListClassUsingGET(_response));
        });
    }

    protected processListClassUsingGET(response: Response): Promise<any[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(item);
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any[]>(null as any);
    }

    /**
     * insertClassStudent
     * @param classId classId
     * @param studentId studentId
     * @param subjectId subjectId
     * @return OK
     */
    insertClassStudentUsingPOST(classId: number, studentId: number, subjectId: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/insert-class-student?";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined and cannot be null.");
        else
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined and cannot be null.");
        else
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (subjectId === undefined || subjectId === null)
            throw new Error("The parameter 'subjectId' must be defined and cannot be null.");
        else
            url_ += "subjectId=" + encodeURIComponent("" + subjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processInsertClassStudentUsingPOST(_response));
        });
    }

    protected processInsertClassStudentUsingPOST(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 201) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * listAttendStudent
     * @param classId classId
     * @param fromDate fromDate
     * @param subjectId subjectId
     * @return OK
     */
    listAttendStudentUsingGET(classId: number, fromDate: string, subjectId: string): Promise<AttendStudent[]> {
        let url_ = this.baseUrl + "/api/listAttendStudent?";
        if (classId === undefined || classId === null)
            throw new Error("The parameter 'classId' must be defined and cannot be null.");
        else
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        if (fromDate === undefined || fromDate === null)
            throw new Error("The parameter 'fromDate' must be defined and cannot be null.");
        else
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (subjectId === undefined || subjectId === null)
            throw new Error("The parameter 'subjectId' must be defined and cannot be null.");
        else
            url_ += "subjectId=" + encodeURIComponent("" + subjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processListAttendStudentUsingGET(_response));
        });
    }

    protected processListAttendStudentUsingGET(response: Response): Promise<AttendStudent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(AttendStudent.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttendStudent[]>(null as any);
    }

    /**
     * getListClass
     * @param subjectId subjectId
     * @param teacherId teacherId
     * @return OK
     */
    getListClassUsingGET(subjectId: string, teacherId: number): Promise<ListClass[]> {
        let url_ = this.baseUrl + "/api/listClass?";
        if (subjectId === undefined || subjectId === null)
            throw new Error("The parameter 'subjectId' must be defined and cannot be null.");
        else
            url_ += "subjectId=" + encodeURIComponent("" + subjectId) + "&";
        if (teacherId === undefined || teacherId === null)
            throw new Error("The parameter 'teacherId' must be defined and cannot be null.");
        else
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetListClassUsingGET(_response));
        });
    }

    protected processGetListClassUsingGET(response: Response): Promise<ListClass[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ListClass.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListClass[]>(null as any);
    }

    /**
     * getListSubject
     * @param teacherId teacherId
     * @return OK
     */
    getListSubjectUsingGET(teacherId: number): Promise<any[]> {
        let url_ = this.baseUrl + "/api/listSubject?";
        if (teacherId === undefined || teacherId === null)
            throw new Error("The parameter 'teacherId' must be defined and cannot be null.");
        else
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetListSubjectUsingGET(_response));
        });
    }

    protected processGetListSubjectUsingGET(response: Response): Promise<any[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(item);
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any[]>(null as any);
    }

    /**
     * getListSubjectByTerm
     * @param studentId (optional) studentId
     * @param termId (optional) termId
     * @return OK
     */
    getListSubjectByTermUsingGET(studentId: number | null | undefined, termId: number | null | undefined): Promise<SubjectDTO[]> {
        let url_ = this.baseUrl + "/api/listsubject?";
        if (studentId !== undefined && studentId !== null)
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        if (termId !== undefined && termId !== null)
            url_ += "termId=" + encodeURIComponent("" + termId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetListSubjectByTermUsingGET(_response));
        });
    }

    protected processGetListSubjectByTermUsingGET(response: Response): Promise<SubjectDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(SubjectDTO.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubjectDTO[]>(null as any);
    }

    /**
     * getListTerm
     * @return OK
     */
    getListTermUsingGET(): Promise<Term[]> {
        let url_ = this.baseUrl + "/api/listterm";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetListTermUsingGET(_response));
        });
    }

    protected processGetListTermUsingGET(response: Response): Promise<Term[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(Term.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Term[]>(null as any);
    }

    /**
     * schedule
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param studentId studentId
     * @return OK
     */
    scheduleUsingGET(dateFrom: string, dateTo: string, studentId: number): Promise<{ [key: string]: ScheduleDTO; }[]> {
        let url_ = this.baseUrl + "/api/scheduleByStudent?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&";
        if (studentId === undefined || studentId === null)
            throw new Error("The parameter 'studentId' must be defined and cannot be null.");
        else
            url_ += "studentId=" + encodeURIComponent("" + studentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processScheduleUsingGET(_response));
        });
    }

    protected processScheduleUsingGET(response: Response): Promise<{ [key: string]: ScheduleDTO; }[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(item);
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: ScheduleDTO; }[]>(null as any);
    }

    /**
     * sendMail
     * @param attachment (optional) 
     * @param msgBody (optional) 
     * @param recipient (optional) 
     * @param subject (optional) 
     * @return OK
     */
    sendMailUsingPOST(attachment: string | null | undefined, msgBody: string | null | undefined, recipient: string | null | undefined, subject: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/sendMail?";
        if (attachment !== undefined && attachment !== null)
            url_ += "attachment=" + encodeURIComponent("" + attachment) + "&";
        if (msgBody !== undefined && msgBody !== null)
            url_ += "msgBody=" + encodeURIComponent("" + msgBody) + "&";
        if (recipient !== undefined && recipient !== null)
            url_ += "recipient=" + encodeURIComponent("" + recipient) + "&";
        if (subject !== undefined && subject !== null)
            url_ += "subject=" + encodeURIComponent("" + subject) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSendMailUsingPOST(_response));
        });
    }

    protected processSendMailUsingPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * sendMailWithAttachment
     * @param attachment (optional) 
     * @param msgBody (optional) 
     * @param recipient (optional) 
     * @param subject (optional) 
     * @return OK
     */
    sendMailWithAttachmentUsingPOST(attachment: string | null | undefined, msgBody: string | null | undefined, recipient: string | null | undefined, subject: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/sendMailWithAttachment?";
        if (attachment !== undefined && attachment !== null)
            url_ += "attachment=" + encodeURIComponent("" + attachment) + "&";
        if (msgBody !== undefined && msgBody !== null)
            url_ += "msgBody=" + encodeURIComponent("" + msgBody) + "&";
        if (recipient !== undefined && recipient !== null)
            url_ += "recipient=" + encodeURIComponent("" + recipient) + "&";
        if (subject !== undefined && subject !== null)
            url_ += "subject=" + encodeURIComponent("" + subject) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSendMailWithAttachmentUsingPOST(_response));
        });
    }

    protected processSendMailWithAttachmentUsingPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * getClassByTeacherId
     * @param teacherId teacherId
     * @return OK
     */
    getClassByTeacherIdUsingGET(teacherId: number): Promise<ClassDTO[]> {
        let url_ = this.baseUrl + "/api/teacher/getClass?";
        if (teacherId === undefined || teacherId === null)
            throw new Error("The parameter 'teacherId' must be defined and cannot be null.");
        else
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetClassByTeacherIdUsingGET(_response));
        });
    }

    protected processGetClassByTeacherIdUsingGET(response: Response): Promise<ClassDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ClassDTO.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClassDTO[]>(null as any);
    }

    /**
     * updateAttend
     * @param attendId attendId
     * @param status status
     * @return OK
     */
    updateAttendUsingPOST(attendId: number, status: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/updateAttend?";
        if (attendId === undefined || attendId === null)
            throw new Error("The parameter 'attendId' must be defined and cannot be null.");
        else
            url_ += "attendId=" + encodeURIComponent("" + attendId) + "&";
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateAttendUsingPOST(_response));
        });
    }

    protected processUpdateAttendUsingPOST(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * changePassword
     * @param newPassword (optional) newPassword
     * @param oldPassword (optional) oldPassword
     * @return OK
     */
    changePasswordUsingPOST(newPassword: string | null | undefined, oldPassword: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/change-password?";
        if (newPassword !== undefined && newPassword !== null)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&";
        if (oldPassword !== undefined && oldPassword !== null)
            url_ += "oldPassword=" + encodeURIComponent("" + oldPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processChangePasswordUsingPOST(_response));
        });
    }

    protected processChangePasswordUsingPOST(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * errorHtml
     * @return OK
     */
    errorHtmlUsingGET(): Promise<ModelAndView> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/html"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processErrorHtmlUsingGET(_response));
        });
    }

    protected processErrorHtmlUsingGET(response: Response): Promise<ModelAndView> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModelAndView.fromJS(resultData200);
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelAndView>(null as any);
    }

    /**
     * errorHtml
     * @return OK
     */
    errorHtmlUsingHEAD(): Promise<ModelAndView> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "HEAD",
            headers: {
                "Accept": "text/html"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processErrorHtmlUsingHEAD(_response));
        });
    }

    protected processErrorHtmlUsingHEAD(response: Response): Promise<ModelAndView> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModelAndView.fromJS(resultData200);
                return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
                return throwException("No Content", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelAndView>(null as any);
    }

    /**
     * errorHtml
     * @return OK
     */
    errorHtmlUsingPOST(): Promise<ModelAndView> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/html"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processErrorHtmlUsingPOST(_response));
        });
    }

    protected processErrorHtmlUsingPOST(response: Response): Promise<ModelAndView> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModelAndView.fromJS(resultData200);
                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelAndView>(null as any);
    }

    /**
     * errorHtml
     * @return OK
     */
    errorHtmlUsingPUT(): Promise<ModelAndView> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "text/html"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processErrorHtmlUsingPUT(_response));
        });
    }

    protected processErrorHtmlUsingPUT(response: Response): Promise<ModelAndView> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModelAndView.fromJS(resultData200);
                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelAndView>(null as any);
    }

    /**
     * errorHtml
     * @return OK
     */
    errorHtmlUsingDELETE(): Promise<ModelAndView> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/html"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processErrorHtmlUsingDELETE(_response));
        });
    }

    protected processErrorHtmlUsingDELETE(response: Response): Promise<ModelAndView> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModelAndView.fromJS(resultData200);
                return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
                return throwException("No Content", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelAndView>(null as any);
    }

    /**
     * errorHtml
     * @return OK
     */
    errorHtmlUsingOPTIONS(): Promise<ModelAndView> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "OPTIONS",
            headers: {
                "Accept": "text/html"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processErrorHtmlUsingOPTIONS(_response));
        });
    }

    protected processErrorHtmlUsingOPTIONS(response: Response): Promise<ModelAndView> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModelAndView.fromJS(resultData200);
                return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
                return throwException("No Content", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelAndView>(null as any);
    }

    /**
     * errorHtml
     * @return OK
     */
    errorHtmlUsingPATCH(): Promise<ModelAndView> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "text/html"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processErrorHtmlUsingPATCH(_response));
        });
    }

    protected processErrorHtmlUsingPATCH(response: Response): Promise<ModelAndView> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModelAndView.fromJS(resultData200);
                return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
                return throwException("No Content", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelAndView>(null as any);
    }

    /**
     * getListAccount
     * @param email (optional) email
     * @param role (optional) role
     * @param status (optional) status
     * @return OK
     */
    getListAccountUsingGET(email: string | null | undefined, role: string | null | undefined, status: number | null | undefined): Promise<AccountDTO[]> {
        let url_ = this.baseUrl + "/get-list-account?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetListAccountUsingGET(_response));
        });
    }

    protected processGetListAccountUsingGET(response: Response): Promise<AccountDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(AccountDTO.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccountDTO[]>(null as any);
    }

    /**
     * getInfo
     * @return OK
     */
    getInfoUsingGET(): Promise<InfoDTO> {
        let url_ = this.baseUrl + "/getinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetInfoUsingGET(_response));
        });
    }

    protected processGetInfoUsingGET(response: Response): Promise<InfoDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = InfoDTO.fromJS(resultData200);
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoDTO>(null as any);
    }

    /**
     * getAllTutorials
     * @return OK
     */
    getAllTutorialsUsingGET(): Promise<Student[]> {
        let url_ = this.baseUrl + "/import/Student";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllTutorialsUsingGET(_response));
        });
    }

    protected processGetAllTutorialsUsingGET(response: Response): Promise<Student[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(Student.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Student[]>(null as any);
    }

    /**
     * uploadFile
     * @param file file
     * @return OK
     */
    uploadFileUsingPOST(file: Blob): Promise<ResponseMessage> {
        let url_ = this.baseUrl + "/import/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = file;

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "multipart/form-data",
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUploadFileUsingPOST(_response));
        });
    }

    protected processUploadFileUsingPOST(response: Response): Promise<ResponseMessage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ResponseMessage.fromJS(resultData200);
                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseMessage>(null as any);
    }

    /**
     * Login
     * @param email (optional) 
     * @param password (optional) 
     * @return OK
     */
    loginUsingPOST(email: string | null | undefined, password: string | null | undefined): Promise<TokenRes> {
        let url_ = this.baseUrl + "/login?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLoginUsingPOST(_response));
        });
    }

    protected processLoginUsingPOST(response: Response): Promise<TokenRes> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = TokenRes.fromJS(resultData200);
                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenRes>(null as any);
    }

    /**
     * register
     * @param email (optional) 
     * @param fullname (optional) 
     * @param password (optional) 
     * @param role (optional) 
     * @return OK
     */
    registerUsingGET(email: string | null | undefined, fullname: string | null | undefined, password: string | null | undefined, role: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/register?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (fullname !== undefined && fullname !== null)
            url_ += "fullname=" + encodeURIComponent("" + fullname) + "&";
        if (password !== undefined && password !== null)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRegisterUsingGET(_response));
        });
    }

    protected processRegisterUsingGET(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * updateInfo
     * @param address (optional) 
     * @param avatar (optional) 
     * @param dob (optional) 
     * @param fullname (optional) 
     * @param gender (optional) 
     * @param phone (optional) 
     * @return OK
     */
    updateInfoUsingPOST(address: string | null | undefined, avatar: string | null | undefined, dob: string | null | undefined, fullname: string | null | undefined, gender: boolean | null | undefined, phone: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/update-info?";
        if (address !== undefined && address !== null)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        if (avatar !== undefined && avatar !== null)
            url_ += "avatar=" + encodeURIComponent("" + avatar) + "&";
        if (dob !== undefined && dob !== null)
            url_ += "dob=" + encodeURIComponent("" + dob) + "&";
        if (fullname !== undefined && fullname !== null)
            url_ += "fullname=" + encodeURIComponent("" + fullname) + "&";
        if (gender !== undefined && gender !== null)
            url_ += "gender=" + encodeURIComponent("" + gender) + "&";
        if (phone !== undefined && phone !== null)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateInfoUsingPOST(_response));
        });
    }

    protected processUpdateInfoUsingPOST(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return throwException("Created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class AccountDTO implements IAccountDTO {
    email?: string | undefined;
    fullname?: string | undefined;
    id?: number | undefined;
    role?: string | undefined;
    status?: number | undefined;

    constructor(data?: IAccountDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.fullname = _data["fullname"];
            this.id = _data["id"];
            this.role = _data["role"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): AccountDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["fullname"] = this.fullname;
        data["id"] = this.id;
        data["role"] = this.role;
        data["status"] = this.status;
        return data;
    }
}

export interface IAccountDTO {
    email?: string | undefined;
    fullname?: string | undefined;
    id?: number | undefined;
    role?: string | undefined;
    status?: number | undefined;
}

export class AttendDTO implements IAttendDTO {
    day?: string | undefined;
    slot?: number | undefined;
    status?: number | undefined;

    constructor(data?: IAttendDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["day"];
            this.slot = _data["slot"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): AttendDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttendDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day;
        data["slot"] = this.slot;
        data["status"] = this.status;
        return data;
    }
}

export interface IAttendDTO {
    day?: string | undefined;
    slot?: number | undefined;
    status?: number | undefined;
}

export class AttendStudent implements IAttendStudent {
    attendId?: number | undefined;
    avatar?: string | undefined;
    fullname?: string | undefined;
    status?: number | undefined;
    studentCode?: string | undefined;

    constructor(data?: IAttendStudent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attendId = _data["attendId"];
            this.avatar = _data["avatar"];
            this.fullname = _data["fullname"];
            this.status = _data["status"];
            this.studentCode = _data["studentCode"];
        }
    }

    static fromJS(data: any): AttendStudent {
        data = typeof data === 'object' ? data : {};
        let result = new AttendStudent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attendId"] = this.attendId;
        data["avatar"] = this.avatar;
        data["fullname"] = this.fullname;
        data["status"] = this.status;
        data["studentCode"] = this.studentCode;
        return data;
    }
}

export interface IAttendStudent {
    attendId?: number | undefined;
    avatar?: string | undefined;
    fullname?: string | undefined;
    status?: number | undefined;
    studentCode?: string | undefined;
}

export class ClassDTO implements IClassDTO {
    classId?: number | undefined;
    className?: string | undefined;

    constructor(data?: IClassDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.className = _data["className"];
        }
    }

    static fromJS(data: any): ClassDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClassDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["className"] = this.className;
        return data;
    }
}

export interface IClassDTO {
    classId?: number | undefined;
    className?: string | undefined;
}

export class InfoDTO implements IInfoDTO {
    address?: string | undefined;
    avatar?: string | undefined;
    dob?: string | undefined;
    email?: string | undefined;
    fullname?: string | undefined;
    gender?: boolean | undefined;
    id?: number | undefined;
    phone?: string | undefined;

    constructor(data?: IInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.avatar = _data["avatar"];
            this.dob = _data["dob"];
            this.email = _data["email"];
            this.fullname = _data["fullname"];
            this.gender = _data["gender"];
            this.id = _data["id"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): InfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["avatar"] = this.avatar;
        data["dob"] = this.dob;
        data["email"] = this.email;
        data["fullname"] = this.fullname;
        data["gender"] = this.gender;
        data["id"] = this.id;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IInfoDTO {
    address?: string | undefined;
    avatar?: string | undefined;
    dob?: string | undefined;
    email?: string | undefined;
    fullname?: string | undefined;
    gender?: boolean | undefined;
    id?: number | undefined;
    phone?: string | undefined;
}

export class ListClass implements IListClass {
    className?: string | undefined;
    id?: number | undefined;

    constructor(data?: IListClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.className = _data["className"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ListClass {
        data = typeof data === 'object' ? data : {};
        let result = new ListClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["className"] = this.className;
        data["id"] = this.id;
        return data;
    }
}

export interface IListClass {
    className?: string | undefined;
    id?: number | undefined;
}

export class ModelAndView implements IModelAndView {
    empty?: boolean | undefined;
    model?: any | undefined;
    modelMap?: { [key: string]: any; } | undefined;
    reference?: boolean | undefined;
    status?: ModelAndViewStatus | undefined;
    view?: View | undefined;
    viewName?: string | undefined;

    constructor(data?: IModelAndView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.empty = _data["empty"];
            this.model = _data["model"];
            if (_data["modelMap"]) {
                this.modelMap = {} as any;
                for (let key in _data["modelMap"]) {
                    if (_data["modelMap"].hasOwnProperty(key))
                        (<any>this.modelMap)![key] = _data["modelMap"][key];
                }
            }
            this.reference = _data["reference"];
            this.status = _data["status"];
            this.view = _data["view"] ? View.fromJS(_data["view"]) : <any>undefined;
            this.viewName = _data["viewName"];
        }
    }

    static fromJS(data: any): ModelAndView {
        data = typeof data === 'object' ? data : {};
        let result = new ModelAndView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["empty"] = this.empty;
        data["model"] = this.model;
        if (this.modelMap) {
            data["modelMap"] = {};
            for (let key in this.modelMap) {
                if (this.modelMap.hasOwnProperty(key))
                    (<any>data["modelMap"])[key] = (<any>this.modelMap)[key];
            }
        }
        data["reference"] = this.reference;
        data["status"] = this.status;
        data["view"] = this.view ? this.view.toJSON() : <any>undefined;
        data["viewName"] = this.viewName;
        return data;
    }
}

export interface IModelAndView {
    empty?: boolean | undefined;
    model?: any | undefined;
    modelMap?: { [key: string]: any; } | undefined;
    reference?: boolean | undefined;
    status?: ModelAndViewStatus | undefined;
    view?: View | undefined;
    viewName?: string | undefined;
}

export class ResponseMessage implements IResponseMessage {
    message?: string | undefined;

    constructor(data?: IResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface IResponseMessage {
    message?: string | undefined;
}

export class ScheduleDTO implements IScheduleDTO {
    className?: string | undefined;
    dayId?: string | undefined;
    slot?: number | undefined;
    statusAttend?: number | undefined;
    subjectName?: string | undefined;
    time?: string | undefined;
    weekday?: string | undefined;

    constructor(data?: IScheduleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.className = _data["className"];
            this.dayId = _data["dayId"];
            this.slot = _data["slot"];
            this.statusAttend = _data["statusAttend"];
            this.subjectName = _data["subjectName"];
            this.time = _data["time"];
            this.weekday = _data["weekday"];
        }
    }

    static fromJS(data: any): ScheduleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["className"] = this.className;
        data["dayId"] = this.dayId;
        data["slot"] = this.slot;
        data["statusAttend"] = this.statusAttend;
        data["subjectName"] = this.subjectName;
        data["time"] = this.time;
        data["weekday"] = this.weekday;
        return data;
    }
}

export interface IScheduleDTO {
    className?: string | undefined;
    dayId?: string | undefined;
    slot?: number | undefined;
    statusAttend?: number | undefined;
    subjectName?: string | undefined;
    time?: string | undefined;
    weekday?: string | undefined;
}

export class Student implements IStudent {
    address?: string | undefined;
    avatar?: string | undefined;
    dob?: string | undefined;
    fullname?: string | undefined;
    gender?: boolean | undefined;
    phone?: string | undefined;
    studentCode?: string | undefined;
    studentId?: number | undefined;

    constructor(data?: IStudent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.avatar = _data["avatar"];
            this.dob = _data["dob"];
            this.fullname = _data["fullname"];
            this.gender = _data["gender"];
            this.phone = _data["phone"];
            this.studentCode = _data["studentCode"];
            this.studentId = _data["studentId"];
        }
    }

    static fromJS(data: any): Student {
        data = typeof data === 'object' ? data : {};
        let result = new Student();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["avatar"] = this.avatar;
        data["dob"] = this.dob;
        data["fullname"] = this.fullname;
        data["gender"] = this.gender;
        data["phone"] = this.phone;
        data["studentCode"] = this.studentCode;
        data["studentId"] = this.studentId;
        return data;
    }
}

export interface IStudent {
    address?: string | undefined;
    avatar?: string | undefined;
    dob?: string | undefined;
    fullname?: string | undefined;
    gender?: boolean | undefined;
    phone?: string | undefined;
    studentCode?: string | undefined;
    studentId?: number | undefined;
}

export class SubjectDTO implements ISubjectDTO {
    classId?: string | undefined;
    className?: string | undefined;
    des?: string | undefined;
    subjectId?: string | undefined;

    constructor(data?: ISubjectDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classId = _data["classId"];
            this.className = _data["className"];
            this.des = _data["des"];
            this.subjectId = _data["subjectId"];
        }
    }

    static fromJS(data: any): SubjectDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classId"] = this.classId;
        data["className"] = this.className;
        data["des"] = this.des;
        data["subjectId"] = this.subjectId;
        return data;
    }
}

export interface ISubjectDTO {
    classId?: string | undefined;
    className?: string | undefined;
    des?: string | undefined;
    subjectId?: string | undefined;
}

export class Term implements ITerm {
    termEnd?: string | undefined;
    termId?: number | undefined;
    termName?: string | undefined;
    termStart?: string | undefined;
    year?: string | undefined;

    constructor(data?: ITerm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.termEnd = _data["termEnd"];
            this.termId = _data["termId"];
            this.termName = _data["termName"];
            this.termStart = _data["termStart"];
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): Term {
        data = typeof data === 'object' ? data : {};
        let result = new Term();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["termEnd"] = this.termEnd;
        data["termId"] = this.termId;
        data["termName"] = this.termName;
        data["termStart"] = this.termStart;
        data["year"] = this.year;
        return data;
    }
}

export interface ITerm {
    termEnd?: string | undefined;
    termId?: number | undefined;
    termName?: string | undefined;
    termStart?: string | undefined;
    year?: string | undefined;
}

export class TokenRes implements ITokenRes {
    img?: string | undefined;
    role?: string | undefined;
    token?: string | undefined;
    userId?: number | undefined;
    username?: string | undefined;

    constructor(data?: ITokenRes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.img = _data["img"];
            this.role = _data["role"];
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): TokenRes {
        data = typeof data === 'object' ? data : {};
        let result = new TokenRes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["img"] = this.img;
        data["role"] = this.role;
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["username"] = this.username;
        return data;
    }
}

export interface ITokenRes {
    img?: string | undefined;
    role?: string | undefined;
    token?: string | undefined;
    userId?: number | undefined;
    username?: string | undefined;
}

export class View implements IView {
    contentType?: string | undefined;

    constructor(data?: IView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): View {
        data = typeof data === 'object' ? data : {};
        let result = new View();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IView {
    contentType?: string | undefined;
}

export enum ModelAndViewStatus {
    ACCEPTED = "ACCEPTED",
    ALREADY_REPORTED = "ALREADY_REPORTED",
    BAD_GATEWAY = "BAD_GATEWAY",
    BAD_REQUEST = "BAD_REQUEST",
    BANDWIDTH_LIMIT_EXCEEDED = "BANDWIDTH_LIMIT_EXCEEDED",
    CHECKPOINT = "CHECKPOINT",
    CONFLICT = "CONFLICT",
    CONTINUE = "CONTINUE",
    CREATED = "CREATED",
    DESTINATION_LOCKED = "DESTINATION_LOCKED",
    EXPECTATION_FAILED = "EXPECTATION_FAILED",
    FAILED_DEPENDENCY = "FAILED_DEPENDENCY",
    FORBIDDEN = "FORBIDDEN",
    FOUND = "FOUND",
    GATEWAY_TIMEOUT = "GATEWAY_TIMEOUT",
    GONE = "GONE",
    HTTP_VERSION_NOT_SUPPORTED = "HTTP_VERSION_NOT_SUPPORTED",
    IM_USED = "IM_USED",
    INSUFFICIENT_SPACE_ON_RESOURCE = "INSUFFICIENT_SPACE_ON_RESOURCE",
    INSUFFICIENT_STORAGE = "INSUFFICIENT_STORAGE",
    INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR",
    I_AM_A_TEAPOT = "I_AM_A_TEAPOT",
    LENGTH_REQUIRED = "LENGTH_REQUIRED",
    LOCKED = "LOCKED",
    LOOP_DETECTED = "LOOP_DETECTED",
    METHOD_FAILURE = "METHOD_FAILURE",
    METHOD_NOT_ALLOWED = "METHOD_NOT_ALLOWED",
    MOVED_PERMANENTLY = "MOVED_PERMANENTLY",
    MOVED_TEMPORARILY = "MOVED_TEMPORARILY",
    MULTIPLE_CHOICES = "MULTIPLE_CHOICES",
    MULTI_STATUS = "MULTI_STATUS",
    NETWORK_AUTHENTICATION_REQUIRED = "NETWORK_AUTHENTICATION_REQUIRED",
    NON_AUTHORITATIVE_INFORMATION = "NON_AUTHORITATIVE_INFORMATION",
    NOT_ACCEPTABLE = "NOT_ACCEPTABLE",
    NOT_EXTENDED = "NOT_EXTENDED",
    NOT_FOUND = "NOT_FOUND",
    NOT_IMPLEMENTED = "NOT_IMPLEMENTED",
    NOT_MODIFIED = "NOT_MODIFIED",
    NO_CONTENT = "NO_CONTENT",
    OK = "OK",
    PARTIAL_CONTENT = "PARTIAL_CONTENT",
    PAYLOAD_TOO_LARGE = "PAYLOAD_TOO_LARGE",
    PAYMENT_REQUIRED = "PAYMENT_REQUIRED",
    PERMANENT_REDIRECT = "PERMANENT_REDIRECT",
    PRECONDITION_FAILED = "PRECONDITION_FAILED",
    PRECONDITION_REQUIRED = "PRECONDITION_REQUIRED",
    PROCESSING = "PROCESSING",
    PROXY_AUTHENTICATION_REQUIRED = "PROXY_AUTHENTICATION_REQUIRED",
    REQUESTED_RANGE_NOT_SATISFIABLE = "REQUESTED_RANGE_NOT_SATISFIABLE",
    REQUEST_ENTITY_TOO_LARGE = "REQUEST_ENTITY_TOO_LARGE",
    REQUEST_HEADER_FIELDS_TOO_LARGE = "REQUEST_HEADER_FIELDS_TOO_LARGE",
    REQUEST_TIMEOUT = "REQUEST_TIMEOUT",
    REQUEST_URI_TOO_LONG = "REQUEST_URI_TOO_LONG",
    RESET_CONTENT = "RESET_CONTENT",
    SEE_OTHER = "SEE_OTHER",
    SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE",
    SWITCHING_PROTOCOLS = "SWITCHING_PROTOCOLS",
    TEMPORARY_REDIRECT = "TEMPORARY_REDIRECT",
    TOO_EARLY = "TOO_EARLY",
    TOO_MANY_REQUESTS = "TOO_MANY_REQUESTS",
    UNAUTHORIZED = "UNAUTHORIZED",
    UNAVAILABLE_FOR_LEGAL_REASONS = "UNAVAILABLE_FOR_LEGAL_REASONS",
    UNPROCESSABLE_ENTITY = "UNPROCESSABLE_ENTITY",
    UNSUPPORTED_MEDIA_TYPE = "UNSUPPORTED_MEDIA_TYPE",
    UPGRADE_REQUIRED = "UPGRADE_REQUIRED",
    URI_TOO_LONG = "URI_TOO_LONG",
    USE_PROXY = "USE_PROXY",
    VARIANT_ALSO_NEGOTIATES = "VARIANT_ALSO_NEGOTIATES",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}